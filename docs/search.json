[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Algorithm/dp_0_to_hero.html",
    "href": "Algorithm/dp_0_to_hero.html",
    "title": "DP 0 to Hero",
    "section": "",
    "text": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nclass Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
  },
  {
    "objectID": "Algorithm/dp_0_to_hero.html#climbing-stairs",
    "href": "Algorithm/dp_0_to_hero.html#climbing-stairs",
    "title": "DP 0 to Hero",
    "section": "",
    "text": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nclass Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        if n == 1:\n            return 1\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        return dp[n]"
  },
  {
    "objectID": "Algorithm/index.html",
    "href": "Algorithm/index.html",
    "title": "Algorithm Topics",
    "section": "",
    "text": "Welcome to my collection of algorithm tutorials and problem-solving guides. Here you’ll find comprehensive explanations, code examples, and practice problems.\n\n\n\n\nLearn how to solve Regular Expression Matching using Dynamic Programming techniques. Covers pattern matching with ‘.’ and ’*’ characters.\n\nTopics Covered: 2D DP, pattern matching, string algorithms\nDifficulty: Intermediate to Advanced\nProblems: Regular Expression Matching (Leetcode 10)\n\n\n\n\n\n\nGraph Algorithms: BFS, DFS, Dijkstra’s Algorithm\nSorting & Searching: Advanced sorting techniques and binary search variations\nTree Algorithms: Tree traversals, LCA, and tree DP\nString Algorithms: KMP, Z-algorithm, and string matching\n\n\nThis section is actively being developed. Check back for new content!"
  },
  {
    "objectID": "Algorithm/index.html#dynamic-programming",
    "href": "Algorithm/index.html#dynamic-programming",
    "title": "Algorithm Topics",
    "section": "",
    "text": "Learn how to solve Regular Expression Matching using Dynamic Programming techniques. Covers pattern matching with ‘.’ and ’*’ characters.\n\nTopics Covered: 2D DP, pattern matching, string algorithms\nDifficulty: Intermediate to Advanced\nProblems: Regular Expression Matching (Leetcode 10)"
  },
  {
    "objectID": "Algorithm/index.html#coming-soon",
    "href": "Algorithm/index.html#coming-soon",
    "title": "Algorithm Topics",
    "section": "",
    "text": "Graph Algorithms: BFS, DFS, Dijkstra’s Algorithm\nSorting & Searching: Advanced sorting techniques and binary search variations\nTree Algorithms: Tree traversals, LCA, and tree DP\nString Algorithms: KMP, Z-algorithm, and string matching\n\n\nThis section is actively being developed. Check back for new content!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Chao’s Blog",
    "section": "",
    "text": "This is where I share my thoughts on programming, algorithms, and software development.\n\n\n\n\nExplore my comprehensive collection of algorithm tutorials and problem-solving guides.\n\nMore content coming soon!"
  },
  {
    "objectID": "index.html#featured-content",
    "href": "index.html#featured-content",
    "title": "Chao’s Blog",
    "section": "",
    "text": "Explore my comprehensive collection of algorithm tutorials and problem-solving guides.\n\nMore content coming soon!"
  },
  {
    "objectID": "Algorithm/dp_regex.html",
    "href": "Algorithm/dp_regex.html",
    "title": "DP: Regular Expression Matching",
    "section": "",
    "text": "Dynamic programming is a technique for solving problems by breaking them down into smaller sub-problems and solving each subproblem only once."
  },
  {
    "objectID": "Algorithm/dp_regex.html#dynamic-programming",
    "href": "Algorithm/dp_regex.html#dynamic-programming",
    "title": "DP Regex",
    "section": "",
    "text": "Dynamic programming is a technique for solving problems by breaking them down into smaller subproblems and solving each subproblem only once.\nRegular expression matching is a problem that can be solved using dynamic programming.\nUse a 2D array to store the results of the subproblems.\ndp[i][j] = True if the first i characters of s match the first j characters of p, False otherwise."
  },
  {
    "objectID": "Algorithm/dp_regex.html#regular-expression-matching",
    "href": "Algorithm/dp_regex.html#regular-expression-matching",
    "title": "DP Regex",
    "section": "1. Regular Expression Matching",
    "text": "1. Regular Expression Matching\n[]\nYou are given a string s and a pattern p, implement regular expression matching with support for ‘.’ and ’*’ where:\n‘.’ Matches any single character. Leetcode 10"
  },
  {
    "objectID": "Algorithm/dp_regex.html#example-of-regular-expression-matching",
    "href": "Algorithm/dp_regex.html#example-of-regular-expression-matching",
    "title": "DP: Regular Expression Matching",
    "section": "Example of Regular Expression Matching",
    "text": "Example of Regular Expression Matching\nA problem from Leetcode 10:\nYou are given a string s and a pattern p, implement regular expression matching with support for ‘.’ and ’*’ where:\n‘.’ Matches any single character. ’*’ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\ns = \"abcabc\"    \np1 = \".*c\"    \np2 = \".*d\""
  },
  {
    "objectID": "Algorithm/dp_regex.html#now-the-formula-is-clear",
    "href": "Algorithm/dp_regex.html#now-the-formula-is-clear",
    "title": "DP Regex",
    "section": "Now the formula is clear,",
    "text": "Now the formula is clear,\n\\[\n\\text{dp}[i][j] =\n\\begin{cases}\n\\text{true} & \\text{if } s[i] \\text{ matches } p[j] \\text{ and } \\text{dp}[i-1][j-1] = \\text{true} \\\\\n\\text{false} & \\text{otherwise}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "Algorithm/dp_regex.html#now-we-can-write-the-code.",
    "href": "Algorithm/dp_regex.html#now-we-can-write-the-code.",
    "title": "DP Regex",
    "section": "Now we can write the code.",
    "text": "Now we can write the code."
  },
  {
    "objectID": "Algorithm/dp_regex.html#formula-derivation",
    "href": "Algorithm/dp_regex.html#formula-derivation",
    "title": "DP: Regular Expression Matching",
    "section": "2. Formula Derivation",
    "text": "2. Formula Derivation\n\nTwo rules\n\nwe can compare single character of the string s[i] with 1 or 2 characters of the pattern p[j],p[j-2]....,\nwe can query the previous results from the DP table dp[i-1][j-1], dp[i][j-2], dp[i-1][j].\n\n\n\nThe flow\nThe diagramm below shows how can we calculate the match result of s[0...i] and p[0...j].\n\n\n\nalt\n\n\nNow the formula seems to be: \\[\n\\text{dp}[i][j] =\n\\begin{cases}\n\\text{true} & \\text{if } p[i] \\neq '*'  \\land s[i] \\text{ matches } p[j] \\land \\text{dp}[i-1][j-1] = \\text{true} \\\\\n\\text{true} & \\text{if } p[i] = '*'  \\land dp[i][j-2] = \\text{true} \\\\\n\\text{true} & \\text{if } p[i] = '*'  \\land s[i] \\text{ matches } p[j-1] \\land \\text{dp}[i-1][j-2] = \\text{true} \\\\\n\\text{true} & \\text{if } p[i] = '*'  \\land s[i] \\text{ matches } p[j-1] \\land \\text{dp}[i-1][j] = \\text{true} \\\\\n\\text{false} & \\text{otherwise}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "Algorithm/dp_regex.html#dp-table",
    "href": "Algorithm/dp_regex.html#dp-table",
    "title": "DP: Regular Expression Matching",
    "section": "1. DP Table",
    "text": "1. DP Table\nLook at the following case.\n\nCase 1\np1 is valid if we have a table like this:\nwe can see that the last cell is T, so p1 is valid.\n\n\n\n\n\n.\n*\nc\n\n\n\n\n\nT\nF\nT\nF\n\n\na\nF\nT\nT\nF\n\n\nb\nF\nF\nT\nF\n\n\nc\nF\nF\nT\nT\n\n\na\nF\nF\nT\nF\n\n\nb\nF\nF\nT\nF\n\n\nc\nF\nF\nT\nT\n\n\n\nThe table is the match result of s[0:i] and p[0:j],\nso the last cell is the match result of s[0:6](the entire string) and p[0:3](the entire pattern). If the result is T, then the entire string matches the entire pattern.\n\n\nHow does each cell is calculated?\n\nthe last cell, p[:3] matches s[:6], also p[:2] matches s[:5]\n\nit is now a dp problem, the cell’s value is the match result of p[:i] and s[:j] and the match result of p[:i-1] and s[:j-1],meaning both should be T.\n\n\n\nCase 2\nNow look at an invalid case:\np2 is invalid because .* can match abcab but d cannot match c\n\n\n\n\n\n.\n*\nd\n\n\n\n\n\nT\nF\nT\nF\n\n\na\nF\nT\nT\nF\n\n\nb\nF\nF\nT\nF\n\n\nc\nF\nF\nT\nF\n\n\na\nF\nF\nT\nF\n\n\nb\nF\nF\nT\nF\n\n\nc\nF\nF\nT\nF\n\n\n\nLook at the last cell, p[:3] matches s[:6], but p[2] does not match s[5], so the last cell is F."
  },
  {
    "objectID": "Algorithm/dp_regex.html#code-example",
    "href": "Algorithm/dp_regex.html#code-example",
    "title": "DP: Regular Expression Matching",
    "section": "3. Code Example",
    "text": "3. Code Example\nPlease not that in the code, when we retrieve character from the string or pattern, we need to use s[i-1] and p[j-1] instead of s[i] and p[j] as the index of the string and pattern is 0-based.\nfrom collections import defaultdict\nclass Solution:\n    def isMatch(self,s, p):\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n     # DP is a table with m+1 rows and n+1 columns\n     # we retrieve dp[i][k], i is the index of s, k is the index of p\n        dp[0][0] = True\n        for j in range(2,n+1):\n            if p[j-1]=='*':\n                dp[0][j]=dp[0][j-2]\n            \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] # zero occurrence\n                    if s[i-1]==p[j-2] or p[j-2]=='.':\n                        dp[i][j]|=dp[i-1][j] or dp[i-1][j-2] # one or more occurrence\n                else:\n                    dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n        return dp[m][n]"
  }
]